# 第2章 数据的机器级表示与处理



[toc]



本章主要内容：
	进位计数制
	二进制定点数的编码表示
	无符号整数和带符号整数的表示
	IEEE 754浮点数表示标准
	西文字符和汉字的编码表示
	C语言中各种类型数据的表示和转换
	数据的宽度和存放顺序
	基本运算及其运算电路



## 2.1 数制和编码

### 2.1.1 信息的二进制编码

数据的不同表现形态：
	外部形式：数值、文字、图、声音、视频······（感觉媒体）
	算法描述的角度：图、表、树、队列、矩阵······
	高级语言程序员的角度：数组、结构、指针、实数、整数、布尔数、字符、字符串······
	机器指令的角度：整数、浮点数、位串（基本数据类型）

数字化编码：
	输入设备：感觉媒体信息 → 二进制编码
		功能：离散化、编码
	数字化编码过程：略
	信息编码的两大要素：基本符号的种类、组合规则

计算机内部采用二进制表示方式的原因：
![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\文本\31-1.png)

每条机器指令的操作数：
	无符号定点整数
	带符号定点整数
	浮点数
	非数值型数据（位串）
![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\图\图2.1.png)

指令所处理的数据类型：
	数值数据：数量
		整数（用定点数表示）：无符号整数、带符号整数
		实数（用浮点数表示）
	非数值数据：位串
		字符数据
		逻辑数据

数值数据的表示方式：
	二进制数
	二进制编码的十进制数（Binary Coded Decimal Number，BCD）

表示一个数值数据要确定三个要素：
	进位计数制
	定/浮点表示
	编码规则



### 2.1.2 进位计数制

![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\文本\32-1.png)

![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\文本\32-2.png)
![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\文本\33-1.png)

![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\文本\33-2.png)

| 进位计数制 |  R   |                    基本符号                    |
| :--------: | :--: | :--------------------------------------------: |
|   二进制   |  2   |                      0、1                      |
|   八进制   |  8   |             0、1、2、3、4、5、6、7             |
|   十进制   |  10  |          0、1、2、3、4、5、6、7、8、9          |
|  十六进制  |  16  | 0、1、2、3、4、5、6、7、8、9、A、B、C、D、E、F |

![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\表\表2.1.png)

后缀字母：
	二进制：B（Binary），如10011B
	八进制：O（Octal）
	十进制（可以省略）：D（Decimal），如56D、56
	十六进制：H（Hexadecimal）
		前缀：0x
		如308FH、0x308F

各进位计数制之间数据的转换方法：

#### 1. R进制数转换成十进制数

R进制数 → 十进制数：按权展开

![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\例题\例2.1.png)

![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\例题\例2.2.png)

![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\例题\例2.3.png)



#### 2. 十进制数转换成R进制数

十进制数 → R进制数：整数部分、小数部分分别进行转换
	整数部分的转换：除基取余，上右下左
	小数部分的转换：乘基取整，上左下右

![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\例题\例2.4.png)

![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\例题\例2.5.png)

![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\例题\例2.6-1.png)
![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\例题\例2.6-2.png)

![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\例题\例2.7.png)



#### 3. 二、八、十六进制数的相互转换

（1）八进制数转换成二进制数

![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\例题\例2.8.png)

（2）十六进制数转换成二进制数

![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\例题\例2.9.png)

（3）二进制数转换成八进制数

![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\文本\35-1.png)

（4）二进制数转换成十六进制数

![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\文本\35-2.png)



### 2.1.3 定点与浮点表示

小数点的表示问题：约定小数点的位置
定点数：小数点位置约定在固定位置的数
浮点数：小数点位置约定为可浮动的数



#### 1. 定点表示

定点表示法：
	定点小数：小数点固定在数的左边
		表示：浮点数的尾数部分
	定点整数：小数点固定在数的最右边
		表示：整数



#### 2. 浮点表示

![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\文本\36-1.png)

![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\文本\36-2.png)



### 2.1.4 定点数的编码表示

符号数字化：
	0：正号
	1：负号

机器数：数值数据在计算机内部编码表示后的数
真值：机器数真正的值（现实世界中带有正负号的数）

![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\文本\37-1.png)



#### 1. 原码表示法

原码表示法 / “符号-数值”（sign and magnitude）表示法：符号位+数值位

![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\文本\37-2.png)

优点：
	与真值的对应关系直观、方便 → 与真值之间的转换简单
	乘除运算：简便
缺点：
	0的表示不唯一，给使用带来不便
	加减运算：复杂

现代计算机：
	整数：不用原码表示
	浮点数的尾数部分：定点原码小数



#### 2. 补码表示法

补码表示法 / “2-补码”（two's complement）表示法：符号位+真值的模2<sup>n</sup>补码
	实现加减运算的统一：用加法来实现减法运算



（1）模运算

模运算系统：
	A = B + K $\times$ M（K为整数）
	记为：A ≡ B(mod M)
	A、B各除以M后的余数相同
	B和A为模M同余
	**一个数与它除以“模”后得到的余数是等价的**

对于某一确定的模，某数A减去小于模的另一数B，可以用A加上-B的补码来代替
→ 补码可以借助加法运算来实现减法运算

![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\例题\例2.10.png)

|  真值  | *补码* | 真值  | *补码* |  真值  | *补码* |  真值  | *补码* |
| :----: | :----: | :---: | :----: | :----: | :----: | :----: | :----: |
| **-6** |  *6*   | **0** |  *0*   | **6**  |  *6*   | **12** |  *0*   |
| **-5** |  *7*   | **1** |  *1*   | **7**  |  *7*   | **13** |  *1*   |
| **-4** |  *8*   | **2** |  *2*   | **8**  |  *8*   | **14** |  *2*   |
| **-3** |  *9*   | **3** |  *3*   | **9**  |  *9*   | **15** |  *3*   |
| **-2** |  *10*  | **4** |  *4*   | **10** |  *10*  | **16** |  *4*   |
| **-1** |  *11*  | **5** |  *5*   | **11** |  *11*  | **17** |  *5*   |

![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\例题\例2.11.png)

 两个n位二进制数在进行运算过程中，可能会产生一个多于n位的结果 → 舍弃高位，保留低n位：
	① 剩下的低n位数不能正确表示运算结果：丢掉的高位是运算结果的一部分，如两个同号数相加
		溢出（overflow）现象
	② 剩下的低n位数能正确表示运算结果：高位的舍去并不影响其运算结果，两个同号数相减/两个异号数相加



（2）补码的定义

![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\文本\39-1.png)



（3）特殊数据的补码表示

![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\例题\例2.12.png)

![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\例题\例2.13.png)

![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\例题\例2.14.png)
① 减少了+0和-0之间的转换
② 少占用一个编码表示，使补码比原码能多表示一个最小负数



（4）补码与真值之间的转换方法

正数的补码：符号位取0，其余各位同真值中对应各位
负数的补码：符号位取1，其余各位由数值部分“各位取反，末位加1”得到

![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\例题\例2.16.png)

由补码求真值：
	符号位为0：真值的符号为正，其数值部分不变
	符号位为1：真值的符号为负，其数值部分的各位由补码“各位取反，末位加1”所得

![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\例题\例2.17.png)

根据补码[X<sub>T</sub>]<sub>补</sub>求[-X<sub>T</sub>]<sub>补</sub>：对[X<sub>T</sub>]<sub>补</sub>“各位取反，末位加1”

![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\例题\例2.18.png)

![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\例题\例2.19.png)

结果溢出时：有的编译器不会做任何提示 → 意想不到的结果

（5）变形补码

变形补码 / 模4补码：双符号位
	左符：真正的符号位
	右符：用来判断溢出

![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\文本\41-1.png)

![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\例题\例2.20.png)



#### 3. 反码表示法

负数的补码：仅各位取反而末位不加1 / 在相应的补码表示中再末位减1

不足：
	0的表示不唯一
	表数范围比补码少一个最小负数
	运算时必须考虑循环进位

反码：
	在计算机中很少被使用
	数码变换的中间表示形式
	数据校验



#### 4. 移码表示法

浮点数：用两个定点数表示
	定点小数：浮点数的尾数
	定点整数：浮点数的阶（指数） → 移码

阶码：阶的编码

偏置常数（bias）：简化对阶操作
![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\文本\41-2.png)



## 2.2 整数的表示

整数 / 定点数：
	无符号整数（unsigned integer）
	带符号整数（signed integer）



### 2.2.1 无符号整数和带符号整数的表示

无符号整数 / 无符号数：正整数、非负整数
	所有二进位都用来表示数值，没有符号位
	场合：全部是正数且不出现负值结果（如地址运算、指针、下标······）

8位无符号整数：0000 0000 ~ 1111 1111
	取值范围：0 ~ 255

带符号整数 / 有符号整数：
	用一个二进位表示符号
	现代计算机中：用补码表示

8位带符号整数：
	表示范围：-128 ~ +127



### 2.2.2 C语言中的整数及其相互转换

C语言：
	无符号整数：unsigned short、unsigned int（unsigned）、unsigned long······
		在常数的后面加一个“u”/“U”，如12345U、0x2B3Cu
	带符号整数：short、int、long······

C语言标准：每种数据类型的最小取值范围

|          | short型 | int型 | long型 |
| :------: | :-----: | :---: | :----: |
| 16位机器 |  16位   | 16位  |        |
| 32位机器 |  16位   | 32位  |  32位  |
| 64位机器 |  16位   | 32位  |  64位  |

long long型：64位（ISO C99）

C语言：
	最早：贝尔实验室，Dennis M. Ritchie
	1977年：Dennis M. Ritchie，C语言编译文本《可移植的C语言编译程序》
	1978年：Brian W. Kernighan、Dennis M. Ritchie，《The C Programming Language》
	1988年：美国国家标准学会（ANSI），ANSI标准
		《The C Programming Language》第2版
	国际标准化组织（ISO）：
		ISO C90：1990年，几乎和ANSI C一样
		ISO C99：1999年
			引进：新的数据类型
			支持：英语以外的字符串文本

C语言：无符号数 ↔ 带符号数
	机器数不变
	对其的解释发生了变化

转换前：负整数
转换后：值很大的正整数

![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\文本\43-1.png)
2 147 483 648 = 2<sup>31</sup>
输出结果：
![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\文本\43-2.png)

C语言标准规定：
	同时参加：无符号整数、带符号整数
	→ 按**无符号整数**进行运算

![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\例题\例2.21-1.png)
![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\例题\例2.21-2.png)



## 2.3 浮点数的表示

浮点数：表示实数



### 2.3.1 浮点数的表示范围

浮点数的表示：两个定点数
	定点小数：浮点数的尾数
	定点整数：浮点数的阶
		阶码：阶的编码
			形式：移码（便于对阶）

![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\例题\例2.22-1.png)
![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\例题\例2.22-2.png)

例2.22的规格化浮点数的表示范围：
![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\文本\45-1.png)

![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\图\图2.3.png)
溢出区：
	下溢区：接近0的区间
	上溢区：向无穷大方向延伸的区间

机器零：
	尾数为0 → 阶码取任何值其值都为0
	表示不唯一
	（通常）唯一表示机器零：阶码、尾数同时为0
	有+0、-0之分



### 2.3.2 浮点数的规格化

浮点数：尾数的位数 → 有效数位
	有效数位↑，数据的精度↑

规格化操作：
	尽可能多地保留有效数字的位数
	使浮点数的表示具有唯一性

规格化数的标志：
	真值的尾数部分：
		最高位：非零数字

规格化操作：
	右规：有效数位进到小数点前面
		尾数每右移一位，阶码加1（阶码有可能溢出）
	左规：尾数出现形如±0.0···0bb···b的运算结果
		尾数每左移一位，阶码减1



### 2.3.3 IEEE 754浮点数标准

20世纪80年代初：
	浮点数表示格式：没有统一标准
	不同结构的计算机之间进行数据传送、程序移植 → 数据格式的转换 → 运算结果的不一致

1985年：IEEE 754
	William Kahan：
		加州大学伯克利分校：数学系教授
		Intel公司：8087浮点处理器（FPU）
		1987年：图灵奖

两种基本浮点格式：

|       |      32位单精度格式      |      64位双精度格式      |
| :---: | :----------------------: | :----------------------: |
| 符号s |           1位            |           1位            |
| 阶码e |           8位            |           11位           |
| 尾数f | 23位<br />有效数字：24位 | 52位<br />有效数字：53位 |

![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\图\图2.4.png)

基数：2（隐含）

尾数：原码
规格化尾数：第一位总为1 → 隐藏位：在尾数中缺省第一位的1
隐藏位“1”：在小数点之前

阶码：移码
	偏置常数：2<sup>n-1</sup>-1（n位移码）
	单精度浮点数的偏置常数：127
	双精度浮点数的偏置常数：1023

IEEE 754：尾数带一个隐藏位，偏置常数用（2<sup>n-1</sup>-1）
	① 尾数可表示的位数多一位 → 浮点数的精度更高
	② 阶码的可表示范围更大 → 浮点数范围更大

![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\表\表2.2.png)



#### 1. 全0阶码全0尾数：+0/-0

一般情况下，+0、-0等效



#### 2. 全0阶码非0尾数：非规格化数

非规格化数：
	阶码：全0
	尾数：不全为0
		高位：一个/几个连续的0
	隐藏位：0

|      |                    单精度浮点数                     |                     双精度浮点数                     |
| :--: | :-------------------------------------------------: | :--------------------------------------------------: |
|  阶  |                        -126                         |                        -1022                         |
|  值  | (-1)<sup>s</sup>$\times$0.f$\times$2<sup>-126</sup> | (-1)<sup>s</sup>$\times$0.f$\times$2<sup>-1022</sup> |

非规格化数：处理阶码下溢
	出现比最小规格化数还小的数 → 程序也能继续进行下去

逐级下溢：
	阶太小（<-126/<-1022）：尾数右移1次，阶码加1
	直到：尾数为0、阶达到可表示的最小值（-126/-1022）
	结果：尾数变为非规格化形式、阶变为最小负数
	如，一个十进制运算系统的最小阶为-99，阶的逐级下溢：
![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\文本\47-1.png)

![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\图\图2.5.png)

![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\文本\47-2.png)
![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\文本\48-1.png)



#### 3. 全1阶码全0尾数：+∞/-∞

引入无穷大数：
	在计算过程出现异常的情况：程序能继续进行下去
	为程序提供错误检测功能

+∞：大于所有有限数
-∞：小于所有有限数

无穷大数：操作数、运算的结果

操作数为无穷大：
![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\文本\48-2.png)



#### 4. 全1阶码非0尾数：NaN

NaN / 非数（Not a Number）：没有定义的数
	不发信号（quiet）NaN / 静止的NaN
	发信号（signaling）NaN / 通知的NaN

![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\表\表2.3.png)

区分：不发信号NaN/发信号NaN
	最高有效位为1：不发信号NaN → 不发异常操作通知、不进行异常处理
	最高有效位为0：发信号NaN → 发一个异常操作通知、进行异常处理
	其余的位：没有定义 → 用其余的位：指定具体的异常条件

没有数学解释的计算（如0/0、0$\times$∞······）：产生一个非数NaN



##### 5. 阶码非全0且非全1：规格化非0数

正常的规格化非0数：

|          |                        单精度                        |                        双精度                         |
| :------: | :--------------------------------------------------: | :---------------------------------------------------: |
| 阶码范围 |                        1~254                         |                        1~2046                         |
| 阶的范围 |                      -126~+127                       |                      -1022~+1023                      |
| 计算公式 | (-1)<sup>s</sup>$\times$1.f$\times$2<sup>e-127</sup> | (-1)<sup>s</sup>$\times$1.f$\times$2<sup>e-1023</sup> |

![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\例题\例2.23.png)

![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\例题\例2.24-1.png)
![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\例题\例2.24-2.png)

![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\表\表2.4.png)

单精度规格化数的个数：254$\times$2<sup>23</sup>=1.98$\times$2<sup>31</sup>
双精度规格化数的个数：2046$\times$2<sup>52</sup>=1.99$\times$2<sup>63</sup>

单精度浮点格式的最小可表示数：0.0···01$\times$2<sup>-126</sup>=2<sup>-23</sup>$\times$2<sup>-126</sup>=2<sup>-149</sup>
双精度浮点格式的最小可表示数：0.0···01$\times$2<sup>-1022</sup>=2<sup>-52</sup>$\times$2<sup>-1022</sup>=2<sup>-1074</sup>

IEEE 754：单精度扩展格式、双精度扩展格式（最小长度、最小精度）
	双精度扩展格式：
		有效数字：≥64位
		总共占用：≥79位

SPARC、PowerPC处理器：128位扩展双精度浮点数格式
	符号位s：1位
	阶码e：15位（偏置常数：16 383）
	尾数f：112位
	采用隐藏位
	有效位数：113位

Intel及其兼容的FPU：80位双精度扩展格式
	符号位s：1位
	阶码e：15位（偏置常数：16 383）
	显示首位有效位（explicit leading significant bit）j：1位
	尾数f：63位
	没有隐藏位
	有效位数：64位



### 2.3.4 C语言中的浮点数类型

C语言的两种浮点数类型：

|                |      float       |      double      |
| :------------: | :--------------: | :--------------: |
|  对应IEEE 754  | 单精度浮点数格式 | 双精度浮点数格式 |
| 十进制有效数字 |     7位左右      |     17位左右     |

扩展双精度：long double
	长度、格式：随编译器、处理器类型的不同而有所不同
		Microsoft Visual C++ 6.0版本以下的编译器：不支持
		IA-32 + gcc编译器：Intel x86 FPU的80位双精度扩展格式
		SPARC、PowerPC + gcc编译器：128位双精度扩展格式

强制类型转换：int、float、double之间：
① int → float：不会发生溢出、有效数字可能会被舍去
② int/float → double：能保留精确值（double的有效位数更多）
③ double → float：可能发生溢出（float表示范围更小）、数据可能被舍入（有效位数变少）
④ float/double → int：可能会向0方向被截断（int没有小数部分）、可能发生溢出（int的表示范围更小）
	1.9999 → 1、-1.9999 → -1

1996年6月4日：Ariane 5火箭

![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\例题\例2.25.png)



## 2.4 十进制数的表示

在计算机内部表示十进制数：
	数字0~9对应的ASCII码字符
	二进制编码的十进制数（Binary Coded Decimal，BCD）



### 2.4.1 用ASCII码字符表示

看成字符串，直接用ASCII码表示：0~9 → 30H~39H

存取一个十进制数：内存的起始地址、字节个数

方便：输入输出
运算：很不方便（含有非数值信息（高4位编码））
	先转换位二进制数/用BCD码表示十进制数



### 2.4.2 用BCD码表示

BCD码：采用二进制编码、通过专门的十进制数运算指令处理
（计算机中）专门的逻辑线路：每4位二进制数按十进制进行处理

多种BCD码方案：

#### 1. 有权BCD码

有权BCD码：每个十进制数位的4个二进制数位（基2码）都有一个确定的权
	最常用：8421码 / 自然BCD码 / NBCD码
		每位的权：8、4、2、1（从左到右）

| 十进制数 | 8421码 |
| :------: | :----: |
|    0     |  0000  |
|    1     |  0001  |
|    2     |  0010  |
|    3     |  0011  |
|    4     |  0100  |
|    5     |  0101  |
|    6     |  0110  |
|    7     |  0111  |
|    8     |  1000  |
|    9     |  1001  |



#### 2. 无权BCD码

无权BCD码：每个十进制数位的4个基2码没有确定的权
	用得较多：余3码、格雷码

| 十进制数 | 余3码 | 格雷码 |
| :------: | :---: | :----: |
|    0     | 0011  |  0000  |
|    1     | 0100  |  0001  |
|    2     | 0101  |  0011  |
|    3     | 0110  |  0010  |
|    4     | 0111  |  0110  |
|    5     | 1000  |  0111  |
|    6     | 1001  |  0101  |
|    7     | 1010  |  0100  |
|    8     | 1011  |  1100  |
|    9     | 1100  |  1101  |



一个十进制数：用多个对应的BCD码组合表示
	每个数字：4位二进制
	两个数字：一个字节
	数符：
		用1位二进制表示：
			1：负数
			0：正数
		用4位二进制表示：放在数字串最后
			1100：正号
			1101：负号
	Pentium处理器：
		十进制数：80位
			第一个字节的最高位：符号位
			后面9个字节：18位十进制数



## 2.5 非数值数据的编码表示

非数值数据：逻辑值、字符、······



### 2.5.1 逻辑值

n位数据：由n个一位数据组成
	存储：一个布尔/二进制数据阵列
	提取：一个数据项中的某位进行操作（如：“置1”、“置0”）

逻辑数据：
	n位二进制数：n个逻辑值
	只能参加：（按位进行）逻辑运算（如：按位“与”、按位“或”、逻辑左移、逻辑右移、······）

逻辑运算指令：处理逻辑数据
算术运算指令：处理数值数据



### 2.5.2 西文字符

西文 / 字符（character）：拉丁字母、数字、标点符号、一些特殊符号
字符集：所有字符的集合
字符：进行数字化编码
字符 → 代码
	码表：代码表
	码表中的代码：唯一性

字符主要用于：
	交换信息：外部设备 ↔ 计算机

使用最广泛的西文字符集及其编码：ASCII码 / 美国标准信息交换码（American Standard Code for Information Interchange）
![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\表\表2.5-1.png)
![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\表\表2.5-2.png)

每个字符：7个二进位b<sub>6</sub>b<sub>5</sub>b<sub>4</sub>b<sub>3</sub>b<sub>2</sub>b<sub>1</sub>b<sub>0</sub>
	高位部分：b<sub>6</sub>b<sub>5</sub>b<sub>4</sub>
	低位部分：b<sub>3</sub>b<sub>2</sub>b<sub>1</sub>b<sub>0</sub>

一个字符在计算机中：用8位表示
	最高一位b<sub>7</sub>：0（一般情况）

ASCII字符编码有以下两个规律：
![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\文本\53-1.png)



### 2.5.3 汉字字符

中文信息的基本组成单位：汉字

汉字系统必须处理以下几种汉字代码：输入码、内码、字模点阵码



#### 1. 汉字的输入码

输入码 / 外码：
	编码表示：汉字 → 按键
	输入码的码元（组成编码的基本元素）：西文键盘中的某个按键



#### 2. 字符集与汉字内码

内码：
	西文字符的内码：ASCII码

1981年：《信息交换用汉字编码字符集·基本集》（GB 2312-80）
	常用汉字：6763个
	汉字 → 标准代码（国标码 / 国标交换码）

GB 2312国标字符集：
	第一部分（687个）：字母、数字、各种符号（英文、俄文、日文平假名与片假名、罗马字母、汉语拼音、······）
	第二部分（3755个）：一级常用汉字（按汉语拼音排列）
	第三部分（3008个）：二级常用汉字（按偏旁部首排列）

GB 2312国标字符集：
	字符（汉字、其他字符） → 唯一的二进制代码：区位码
	码表：
		94行（0~93行） → 区号：行号
		94列（0~93列） → 位号：列号
	区位码：区号 + 位号
		区号（在左）：7位
		位号（在右）：7位

区位码 ≠ 国标码（国标交换码）

国标码：区号 + 位号（两个字节）
	区号 = 区位码的区号 + 32（20H）：7位（一个字节）
	位号 = 区位码的位号 + 32（20H）：7位（一个字节）

予以汉字信息特别的标识（区分单字节的ASCII码）：
	两个字节的最高位（b<sub>7</sub>）：1
	→ 机内码 / 汉字内码

例如：汉字“大”
	区号：20
	位号：83
	区位码：1453H
	国标码：3473H
	机内码：B4F3H

|        |        区号        |        位号        |
| :----: | :----------------: | :----------------: |
| 区位码 | 0001 0100 B（14H） | 0101 0011 B（53H） |
| 国标码 | 0011 0100 B（34H） | 0111 0011 B（73H） |
| 机内码 | 1011 0100 B（B4H） | 1111 0011 B（F3H） |

区位码 + 2020H = 国标码
国标码 + 8080H = 机内码

国际标准 ISO/IEC 10646
	包括：全世界现代书面语言文字所使用的所有字符
	UCS-4：4字节/字符
	UCS-2：2字节/字符

CJK编码：
	我国（包括香港、台湾地区）、日本、韩国
	统一的汉字字符集
	2万多个汉字、符号
	编码：2字节（UCS-2）
	国家标准（GB 13000）

Unicode
	美国微软公司：Windows操作系统（中文版）
	中西统一编码
	中、日、韩三国常用的约2万汉字
	编码：2字节
	一致：ISO/IEC 10646的UCS-2



#### 3. 汉字的字模点阵码和轮廓描述

字形信息库 / 字库（font library）：一套汉字的所有字符的形状描述信息（字形描述信息）
不同的字体（如：宋体、仿宋、楷体、黑体、······） → 不同的字库

汉字的字形主要有两种描述方法：
	字模点阵描述：
		字模点阵码：由“0”和“1”组成的方阵
			如：16$\times$16、24$\times$24、32$\times$32、······
	轮廓描述：
		直线、曲线的数学描述公式
		两类国标标准：Adobe Type 1、True Type
		精度：高
		字形大小：任意变化



## 2.6 数据的宽度和存储

### 2.6.1 数据的宽度和单位

比特 / 位元 / 位（bit）：二进制信息的最小单位
字节 / 位组（Byte）：在计算机内部，二进制信息的计量单位
1个字节 = 8个比特
b：比特
B：字节

字（word）：计算机中运算、处理二进制信息时的单位
	2字节、4字节、8字节、16字节

字长 = CPU内部用于整数运算的数据通路的宽度
= CPU内部用于整数运算的运算器位数、通用寄存器宽度

CPU内部数据通路：CPU内部的数据流经的路径、路径上的部件（CPU内部进行数据运算、存储、传送的部件）

字：被处理信息的单位
	度量：各种数据类型的宽度
Intel x86微处理器：
	字：16位
	单字宽度（16位）：无符号整数、带符号整数
	双字宽度（32位）：无符号整数、带符号整数

字长：进行数据运算、存储、传送的部件的宽度
	反映：计算机处理信息的一种能力

**“字”和“字长”的长度可以一样，也可以不一样**

Intel微处理器：
	从80386开始：
		机器：≥32位
		字长：≥32位
		字：16位
		双字：32位

表示二进制信息存储容量：
	单位词头：
![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\文本\56-1.png)

描述距离、频率等数值：用10的幂次表示
时钟频率 → 总线带宽、外设数据传输率的度量单位：10的幂次

K：1024
k：1000
其他前缀字母：大写 → 表示的大小：由其上下文决定

带宽单位：
![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\文本\56-2.png)

整数运算指令：单字节、双字节、4字节、8字节
浮点数运算指令：4字节、8字节

![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\表\表2.6.png)
短整数：2字节
普通int型整数：4字节
长整数的宽度 = 机器字长的宽度

执政的宽度 = 长整数的宽度 = 机器字长的宽度

浮点数的两种类型：
	float：IEEE 754单精度格式
	double：IEEE 754双精度格式

同一类型的数据：不是所有机器都采用相同的数据宽度
相应的ABI规范 → 具体数据宽度



### 2.6.2 数据的存储和排列顺序

最左位（leftmost）、最右位（rightmost） → 发生歧义

最低有效位（Least Significant Bit，LSB）：数的最低位
最高有效位（Most Significant Bit，MSB）：数的最高位

带符号数：
	最高位：符号位
	→ MSB：符号位

例如：
	数“5”在32位机器上用int类型表示：0000 0000 0000 0000 0000 0000 0000 0101
	最前面的一位：0 → MSB = 0
	最后面的一位：1 → LSB = 1

最低有效字节（Least Significant Byte，LSB）
最高有效字节（Most Significant Byte，MSB）

现代计算机：字节编址方式

int型变量i：
	地址：0800H
	机器数：0123 4567H
	4个字节：01H、23H、45H、67H

两种排列方式：
	大端（big endian）
	小端（little endian）
![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\图\图2.6.png)

大端方式：
	小地址单元：最高有效字节
	大地址单元：最低有效字节
	数据的地址：MSB所在的地址
	采用：IBM 360/370、Motorola 68k、MIPS、Sparc、HP PA、······

小端方式：
	小地址单元：最低有效字节
	大地址单元：最高有效字节
	数据的地址：LSB所在的地址
	采用：Intel 80x86、DEC VAX、······

排列顺序不同的系统之间进行数据通信：顺序转换
发送方机器的内部表示格式 → 网络标准 → 接收方机器的内部表示格式

文件格式、处理程序：音频、视频、图像、······
	→ 字节顺序问题
	小端方式：GIF、PC Paintbrush、Microsoft RTF、······
	大端方式：Adobe Photoshop、JPEG、MacPaint、······

了解字节顺序：
	调试底层机器级程序：清楚每个数据的字节顺序 → 将一个机器数正确转换为真值

反汇编器
反汇编：汇编的逆过程（指令的机器代码 → 汇编表示）
IA-32处理器的机器级代码表示文本：
![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\文本\58-1.png)
80483d2：地址（十六进制表示形式）
89 85 a0 fe ff ff：指令的机器代码
mov %eax, 0xfffffea0(%ebp)：指令的汇编形式
![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\文本\58-2.png)
立即数：补码表示的带符号整数
	补码：0xfffffea0
	真值：-1 0110 000 B = -352
	在存储单元中存放的字节序列：A0H、FEH、FFH、FFH
第二个操作数：
	有效地址：将寄存器%ebp的内容减352后得到的值
处理器：
	小端方式：数据的字节按照相反的顺序显示

![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\例题\例2.26-1.png)
![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\例题\例2.26-2.png)
![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\例题\例2.26-3.png)
![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\例题\例2.26-4.png)

![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\例题\例2.27-1.png)
![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\例题\例2.27-2.png)
![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\例题\例2.27-3.png)

C语言表达式：
	规则集合：完成数据类型的自动转换

C语言程序：
	数据类型转换的基本规则：
	① 表达式：（unsigned）char、（unsigned）short → int
	② 包含两种数据类型的任何运算：较低级别的数据类型 → 较高级别的数据类型
	③ 数据类型级别：long double ＞ double ＞ float ＞ unsigned long long ＞ long long ＞ unsigned long ＞long ＞ unsigned int ＞ int；long、int具有相同位数时：unsigned int ＞ long
	④ 赋值语句：计算结果 → 要被赋值的那个变量的类型
		提升（被赋值的变量级别高）：等值转换 → 表数范围更大（扩展操作、整数类型 → 浮点数类型） → （一般情况下）不会有溢出问题
		降级（被赋值的变量级别低）：表数范围缩小 → （可能）导致数据溢出问题



## 2.7 数据的基本运算

计算机内部：运算部件的位数有限 → 出现意料之外的运算结果
	两个正数相加 → 一个负数
	关系表达式“x < y”、“x - y < 0”：产生不同的结果
		例如：![](D:\Notes\CS_Books\计算机系统\计算机系统基础_袁春风等\img\文本\61-1.png)

程序员：
	明白：有关数据表示及其运算等方面的基本原理

计算机硬件的设计目标：软件需求



### 2.7.1 按位运算和逻辑运算



