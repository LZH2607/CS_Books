# 第2章 信息的表示和处理



[toc]



现代计算机存储和处理的信息：二值信号
二进制数字 / 位（bit）

十进制（以10为基数）：
	使用了1000多年
	起源：印度
	12世纪：阿拉伯数学家，改进
	13世纪：意大利数学家Leonardo Pisano（大约公元1170-1250，Fibonacci），带到西方

二值信号：
	很容易地被表示、存储、传输
		穿孔卡片：有洞/无洞
		导线：高电压/低电压
		磁场：顺时针/逆时针
	对二值信号进行存储和执行计算的电子电路：简单、可靠

把位组合在一起 + 解释（interpretation）：赋予不同的可能位模式以含意 → 表示任何有限集合的元素
	二进制数字系统：编码非负数
	标准的字符码：编码字母、符号
	负数表示
	实数近似值的编码

无符号（unsigned）编码：大于或者等于零的数字
补码（two's-complement）编码：有符号整数（可以为正或者为负的数字）
浮点数（floating-point）编码：实数的科学计数法（以2为基数的版本）

计算机的表示法：用有限数量的位来对一个数字编码

溢出（overflow）：结果太大，不能表示

整数运算：满足真正整数运算的许多性质，如乘法：结合律、交换律
浮点运算：完全不同的数学属性
	不可结合：
		C表达式(3.14+1e20)-1e20 → 0.0
		C表达式3.14+(1e20-1e20) → 3.14

整数运算、浮点数运算有不同的数学属性：处理数字表示有限性的方式不同
	整数的表示：相对较小的数值范围，精确的
	浮点数的表示：较大的数值范围，近似的

研究数字的实际表示：
	了解：
		可以表示的值的范围
		不同算术运算的属性
	编写的程序：
		在全部数值范围内正确工作
		具有可以跨越不同机器、操作系统、编译器组合的可移植性

计算机算术运算的微妙细节 → 大量计算机的安全漏洞

数字的位级表示 → 进行算术运算的方式
	编译器：优化算术表达式求值的性能

基于：一组核心的数学原理
	编码：基本定义、属性（可表示的数字的范围、位级表示、算术运算的属性）

怎样阅读本章：
	略

C标准：允许多种实现方式
Java标准：精确具体（数据的格式、编码）

C编程语言的演变：
	最早开发：贝尔实验室，Dennis Ritchie
	目的：和Unix操作系统一起使用
	1989年：ANSI C（美国国家标准学会）
	国际标准化组织：
		ISO C90（1990年）：几乎和ANSI C一样
		ISO C99（1999年）：引入：新的数据类型；支持：使用不符合英语语言字符的文本字符串
		ISO C11（2011年）：添加：数据类型、特性
	GNU编译器套装（GNU Compiler Collection，GCC）
	![](D:\Notes\CS_Books\计算机系统\深入理解计算机系统_布莱恩特等\img\图\图2-1.png)



## 2.1 信息存储

字节（byte）：8位，最小的可寻址的内存单位
虚拟内存（virtual memory）
地址（address）
虚拟地址空间（virtual address space）：
	所有可能地址的集合
	展现给机器级程序的概念性映像
	实际的实现：
		动态随机访问存储器（DRAM）、闪存、磁盘存储器、特殊硬件
		操作系统软件

程序对象（program object）：程序数据、指令、控制信息
（C语言）指针的值：某个存储块的第一个字节的虚拟地址
C编译器：指针 ↔️ 类型信息

C语言中指针的作用：
	指针：引用数据结构（包括数组）的元素
		值：某个对象的位置
		类型：那个位置上所存储对象的类型（如整数、浮点数）



### 2.1.1 十六进制表示法

十六进制（hexadecimal）数：
	以16为基数
	16个可能的值：‘0’、‘1’、‘2’、‘3’、‘4’、‘5’、‘6’、‘7’、‘8’、‘9’、‘A’、‘B’、‘C’、‘D’、‘E’、‘F’

字节：8位
	值域：
		二进制：00000000<sub>2</sub> ~ 11111111<sub>2</sub>
		十进制：0<sub>10</sub> ~ 255<sub>10</sub>
		十六进制：00<sub>16</sub> ~ FF<sub>16</sub>
![](D:\Notes\CS_Books\计算机系统\深入理解计算机系统_布莱恩特等\img\图\图2-2.png)

C语言的十六进制的值：
	以0x或0X开头
	大写：0xFA1D37B
	小写：0xfa1d37b
	大小写混合：0xFa1D37b

十六进制数字：0x173A4C → 二进制数字：000101110011101001001100
![](D:\Notes\CS_Books\计算机系统\深入理解计算机系统_布莱恩特等\img\文本\25-1.png)

二进制数字：1111001010110110110011 → 十六进制数字：0x3CADB3
![](D:\Notes\CS_Books\计算机系统\深入理解计算机系统_布莱恩特等\img\文本\25-2.png)

x：2的非负整数n次幂（x=2<sup>n</sup>）
	二进制数字：（二进制的）1后面跟n个（二进制的）0
	十六进制数字：
		n=i+4j，其中0≤i≤3
		i=0：开头为（十六进制的）1，后面跟j个（十六进制的）0
		i=1：开头为（十六进制的）2，后面跟j个（十六进制的）0
		i=2：开头为（十六进制的）4，后面跟j个（十六进制的）0
		i=3：开头为（十六进制的）8，后面跟j个（十六进制的）0

十进制数字 ↔ 十六进制数字
![](D:\Notes\CS_Books\计算机系统\深入理解计算机系统_布莱恩特等\img\文本\26-1.png)



### 2.1.2 字数据大小

字长（word size）：指针数据的标称大小（nominal size）
字长 → 虚拟地址空间的最大大小
字长：w位 → 虚拟地址的范围：0 ~ 2<sup>w</sup>-1（程序最多访问2<sup>w</sup>个字节）

从32位机器到64位机器的迁移：
	为大型科学和数据库应用设计的高端机器
	台式机、笔记本电脑
	智能手机的处理器

32位字长：
	虚拟地址空间：4千兆字节 / 4GB（刚刚超过4$\times$10<sup>9</sup>字节）
64位字长：
	虚拟地址空间：16EB（大约是1.84$\times$10<sup>19</sup>字节）

程序prog.c：
	可以在32位、64位机器上运行：gcc -m32 prog.c（32位程序）
	只能在64位机器上运行：gcc -m64 prog.c（64位程序）

C语言各种数据类型分配的字节数：
![](D:\Notes\CS_Books\计算机系统\深入理解计算机系统_布莱恩特等\img\图\图2-3.png)

2.2节：C标准保证的字节数、典型的字节数

整数 / 有符号的：负数、零、正数
无符号的：非负数

ISO C99引入的一类数据类型：数据大小固定，不随编译器和机器设置而变化
	int32_t（4个字节）、int64_t（8个字节）

数据类型char：
	大多数编译器、机器：有符号数（C标准：不保证）
	程序员：应该用有符号字符的声明（signed）

C语言允许存在多种形式：关键字的顺序、省略可选关键字
如，下面所有的声明都是一个意思：

```c
unsigned long
unsigned long int
long unsigned
long unsigned int
```

可移植性：使程序对不同数据类型的确切大小不敏感

C语言标准对不同数据类型的数字范围：设置了下界，没有上界



### 2.1.3 寻址和字节顺序

跨越多字节的程序对象的两个规则：对象的地址、在内存中如何排列这些字节

整数：
	w位：[x<sub>w-1</sub>, x<sub>w-2</sub>, ... , x<sub>1</sub>, x<sub>0</sub>]
	最高有效位：x<sub>w-1</sub>
	最低有效位：x<sub>0</sub>
	w是8的倍数
	最高有效字节：[x<sub>w-1</sub>, x<sub>w-2</sub>, ... , x<sub>w-8</sub>]
	最低有效字节：[x<sub>7</sub>, x<sub>6</sub>, ... , x<sub>0</sub>]

小端法（little endian）：最低有效字节在最前面
大端法（big endian）：最高有效字节在最前面

![](D:\Notes\CS_Books\计算机系统\深入理解计算机系统_布莱恩特等\img\文本\29-1.png)

大多数Intel兼容机：小端模式
IBM和Oracle（从其2010年收购Sun Microsystems开始）的大多数机器：大端模式
双端法（bi-endian）：可以配置成作为大端/小端的机器
ARM处理器：小端模式/大端模式
Android（来自Google）：小端模式
IOS（来着Apple）：小端模式

Jonathan Swift：《格利佛游记》（Gulliver's Travels）

字节顺序：大多数应用程序员：完全不可见

在不同类型的机器之间通过网络传送二进制数据：
	网络应用程序的代码编写：遵守已建立的关于字节顺序的规则
		发送方机器的内部表示 → 网络标准 → 接收方机器的内部表示

阅读表示整数数据的字节序列（检查机器级程序）：
	Intel x86-64处理器的机器级代码的文本表示：
![](D:\Notes\CS_Books\计算机系统\深入理解计算机系统_布莱恩特等\img\文本\30-1.png)
	反汇编器（disassembler）：确定可执行程序文件所表示的指令序列
	十六进制字节串01 05 43 0b 20 00：一条指令的字节级表示
		把一个字长的数据加到一个值上
		该值的存储地址：0x200b43加上当前程序计数器的值
		当前程序计数器的值：下一条将要执行指令的地址
	最后4个字节：43 0b 20 00
	→ 按照相反的顺序写出：00 20 0b 43
	→ 去掉开头的0：0x200b43
	书写字节序：
		最低位字节：左边
		最高位字节：右边
	通常书写数字：
		最低有效位：右边
		最高有效位：左边

编写规避正常的类型系统的程序：
	C语言：强制类型转换（cast）、联合（union） → 允许以一种数据类型引用一个对象

![](D:\Notes\CS_Books\计算机系统\深入理解计算机系统_布莱恩特等\img\图\图2-4.png)
byte_pointer：指向类型为“unsigned char”的对象的指针

![](D:\Notes\CS_Books\计算机系统\深入理解计算机系统_布莱恩特等\img\图\图2-5.png)

```c
#include <stdio.h>

typedef unsigned char* byte_pointer;

void show_bytes(byte_pointer start, size_t len) {
	size_t i;
	for (int i = 0; i < len; i++) {
		printf(" %.2x", start[i]);
	}
	printf("\n");
}

void show_int(int x) {
	show_bytes((byte_pointer)&x, sizeof(int));
}

void show_float(float x) {
	show_bytes((byte_pointer)&x, sizeof(float));
}

void show_pointer(void* x) {
	show_bytes((byte_pointer)&x, sizeof(void*));
}

void test_show_bytes(int val) {
	int ival = val;
	float fval = (float)ival;
	int* pval = &ival;
	show_int(ival);
	show_float(fval);
	show_pointer(pval);
}

int main() {
	int x = 12345;
	test_show_bytes(x);

	return 0;
}
```

运行结果：

```
 39 30 00 00
 00 e4 40 46
 14 f4 6f 9f 11 00 00 00
```

![](D:\Notes\CS_Books\计算机系统\深入理解计算机系统_布莱恩特等\img\图\图2-6.png)

|          | 操作系统 |         处理器         |
| :------: | :------: | :--------------------: |
| Linux 32 |  Linux   |       Intel IA32       |
| Windows  | Windows  |       Intel IA32       |
|   Sun    | Solaris  | Sun Microsystems SPARC |
| Linux 64 |  Linux   |      Intel x86-64      |

12345的十六进制表示：0x00003039
小端法机器：Linux 32、Windows、Linux 64
	最低有效字节值0x39：最先输出
大端法机器：Sun
	最低有效字节值0x39：最后输出

指针值：完全不同
	不同的机器/操作系统配置：使用不同的存储分配规则

4字节地址：Linux 32、Windows、Sun
8字节地址：Linux 64

对数值12345编码：
	整型：0x00003039
	浮点数：0x4640E400
	有13个相匹配的位的序列：
![](D:\Notes\CS_Books\计算机系统\深入理解计算机系统_布莱恩特等\img\文本\33-1.png)



### 2.1.4 表示字符串

C语言：
	字符串：以null（其值为0）字符结尾的字符数组
		每个字符：某个标准编码
			ASCII字符码：
				十进制数字*x*：0x3*x*
				终止字节：0x00
