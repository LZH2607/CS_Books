# 第2章 信息的表示和处理



[toc]



现代计算机存储和处理的信息：二值信号
二进制数字 / 位（bit）

十进制（以10为基数）：
	使用了1000多年
	起源：印度
	12世纪：阿拉伯数学家，改进
	13世纪：意大利数学家Leonardo Pisano（大约公元1170-1250，Fibonacci），带到西方

二值信号：
	很容易地被表示、存储、传输
		穿孔卡片：有洞/无洞
		导线：高电压/低电压
		磁场：顺时针/逆时针
	对二值信号进行存储和执行计算的电子电路：简单、可靠

把位组合在一起 + 解释（interpretation）：赋予不同的可能位模式以含意 → 表示任何有限集合的元素
	二进制数字系统：编码非负数
	标准的字符码：编码字母、符号
	负数表示
	实数近似值的编码

无符号（unsigned）编码：大于或者等于零的数字
补码（two's-complement）编码：有符号整数（可以为正或者为负的数字）
浮点数（floating-point）编码：实数的科学计数法（以2为基数的版本）

计算机的表示法：用有限数量的位来对一个数字编码

溢出（overflow）：结果太大，不能表示

整数运算：满足真正整数运算的许多性质，如乘法：结合律、交换律
浮点运算：完全不同的数学属性
	不可结合：
		C表达式(3.14+1e20)-1e20 → 0.0
		C表达式3.14+(1e20-1e20) → 3.14

整数运算、浮点数运算有不同的数学属性：处理数字表示有限性的方式不同
	整数的表示：相对较小的数值范围，精确的
	浮点数的表示：较大的数值范围，近似的

研究数字的实际表示：
	了解：
		可以表示的值的范围
		不同算术运算的属性
	编写的程序：
		在全部数值范围内正确工作
		具有可以跨越不同机器、操作系统、编译器组合的可移植性

计算机算术运算的微妙细节 → 大量计算机的安全漏洞

数字的位级表示 → 进行算术运算的方式
	编译器：优化算术表达式求值的性能

基于：一组核心的数学原理
	编码：基本定义、属性（可表示的数字的范围、位级表示、算术运算的属性）

怎样阅读本章：
	略

C标准：允许多种实现方式
Java标准：精确具体（数据的格式、编码）

C编程语言的演变：
	最早开发：贝尔实验室，Dennis Ritchie
	目的：和Unix操作系统一起使用
	1989年：ANSI C（美国国家标准学会）
	国际标准化组织：
		ISO C90（1990年）：几乎和ANSI C一样
		ISO C99（1999年）：引入：新的数据类型；支持：使用不符合英语语言字符的文本字符串
		ISO C11（2011年）：添加：数据类型、特性
	GNU编译器套装（GNU Compiler Collection，GCC）
	![](D:\Notes\CS_Books\计算机系统\深入理解计算机系统_布莱恩特等\img\图\图2-1.png)



## 2.1 信息存储

字节（byte）：8位，最小的可寻址的内存单位
虚拟内存（virtual memory）
地址（address）
虚拟地址空间（virtual address space）：
	所有可能地址的集合
	展现给机器级程序的概念性映像
	实际的实现：
		动态随机访问存储器（DRAM）、闪存、磁盘存储器、特殊硬件
		操作系统软件

程序对象（program object）：程序数据、指令、控制信息
（C语言）指针的值：某个存储块的第一个字节的虚拟地址
C编译器：指针 ↔️ 类型信息

C语言中指针的作用：
	指针：引用数据结构（包括数组）的元素
		值：某个对象的位置
		类型：那个位置上所存储对象的类型（如整数、浮点数）



### 2.1.1 十六进制表示法

十六进制（hexadecimal）数：
	以16为基数
	16个可能的值：‘0’、‘1’、‘2’、‘3’、‘4’、‘5’、‘6’、‘7’、‘8’、‘9’、‘A’、‘B’、‘C’、‘D’、‘E’、‘F’

字节：8位
	值域：
		二进制：00000000<sub>2</sub> ~ 11111111<sub>2</sub>
		十进制：0<sub>10</sub> ~ 255<sub>10</sub>
		十六进制：00<sub>16</sub> ~ FF<sub>16</sub>
![](D:\Notes\CS_Books\计算机系统\深入理解计算机系统_布莱恩特等\img\图\图2-2.png)

C语言的十六进制的值：
	以0x或0X开头
	大写：0xFA1D37B
	小写：0xfa1d37b
	大小写混合：0xFa1D37b

十六进制数字：0x173A4C → 二进制数字：000101110011101001001100
![](D:\Notes\CS_Books\计算机系统\深入理解计算机系统_布莱恩特等\img\文本\25-1.png)

二进制数字：1111001010110110110011 → 十六进制数字：0x3CADB3
![](D:\Notes\CS_Books\计算机系统\深入理解计算机系统_布莱恩特等\img\文本\25-2.png)

x：2的非负整数n次幂（x=2<sup>n</sup>）
	二进制数字：（二进制的）1后面跟n个（二进制的）0
	十六进制数字：
		n=i+4j，其中0≤i≤3
		i=0：开头为（十六进制的）1，后面跟j个（十六进制的）0
		i=1：开头为（十六进制的）2，后面跟j个（十六进制的）0
		i=2：开头为（十六进制的）4，后面跟j个（十六进制的）0
		i=3：开头为（十六进制的）8，后面跟j个（十六进制的）0

十进制数字 ↔ 十六进制数字
![](D:\Notes\CS_Books\计算机系统\深入理解计算机系统_布莱恩特等\img\文本\26-1.png)



### 2.1.2 字数据大小

字长（word size）：指针数据的标称大小（nominal size）
字长 → 虚拟地址空间的最大大小
字长：w位 → 虚拟地址的范围：0 ~ 2<sup>w</sup>-1（程序最多访问2<sup>w</sup>个字节）

从32位机器到64位机器的迁移：
	为大型科学和数据库应用设计的高端机器
	台式机、笔记本电脑
	智能手机的处理器

32位字长：
	虚拟地址空间：4千兆字节 / 4GB（刚刚超过4$\times$10<sup>9</sup>字节）
64位字长：
	虚拟地址空间：16EB（大约是1.84$\times$10<sup>19</sup>字节）

程序prog.c：
	可以在32位、64位机器上运行：gcc -m32 prog.c（32位程序）
	只能在64位机器上运行：gcc -m64 prog.c（64位程序）

C语言各种数据类型分配的字节数：
![](D:\Notes\CS_Books\计算机系统\深入理解计算机系统_布莱恩特等\img\图\图2-3.png)

2.2节：C标准保证的字节数、典型的字节数

整数 / 有符号的：负数、零、正数
无符号的：非负数

ISO C99引入的一类数据类型：数据大小固定，不随编译器和机器设置而变化
	int32_t（4个字节）、int64_t（8个字节）

数据类型char：
	大多数编译器、机器：有符号数（C标准：不保证）
	程序员：应该用有符号字符的声明（signed）

C语言允许存在多种形式：关键字的顺序、省略可选关键字
如，下面所有的声明都是一个意思：

```c
unsigned long
unsigned long int
long unsigned
long unsigned int
```

可移植性：使程序对不同数据类型的确切大小不敏感

C语言标准对不同数据类型的数字范围：设置了下界，没有上界



### 2.1.3 寻址和字节顺序

跨越多字节的程序对象的两个规则：对象的地址、在内存中如何排列这些字节

整数：
	w位：[x<sub>w-1</sub>, x<sub>w-2</sub>, ... , x<sub>1</sub>, x<sub>0</sub>]
	最高有效位：x<sub>w-1</sub>
	最低有效位：x<sub>0</sub>
	w是8的倍数
	最高有效字节：[x<sub>w-1</sub>, x<sub>w-2</sub>, ... , x<sub>w-8</sub>]
	最低有效字节：[x<sub>7</sub>, x<sub>6</sub>, ... , x<sub>0</sub>]

小端法（little endian）：最低有效字节在最前面
大端法（big endian）：最高有效字节在最前面

![](D:\Notes\CS_Books\计算机系统\深入理解计算机系统_布莱恩特等\img\文本\29-1.png)

大多数Intel兼容机：小端模式
IBM和Oracle（从其2010年收购Sun Microsystems开始）的大多数机器：大端模式
双端法（bi-endian）：可以配置成作为大端/小端的机器
ARM处理器：小端模式/大端模式
Android（来自Google）：小端模式
IOS（来着Apple）：小端模式

Jonathan Swift：《格利佛游记》（Gulliver's Travels）

字节顺序：大多数应用程序员：完全不可见

在不同类型的机器之间通过网络传送二进制数据：
	网络应用程序的代码编写：遵守已建立的关于字节顺序的规则
		发送方机器的内部表示 → 网络标准 → 接收方机器的内部表示

阅读表示整数数据的字节序列（检查机器级程序）：
	Intel x86-64处理器的机器级代码的文本表示：
![](D:\Notes\CS_Books\计算机系统\深入理解计算机系统_布莱恩特等\img\文本\30-1.png)
	反汇编器（disassembler）：确定可执行程序文件所表示的指令序列
	十六进制字节串01 05 43 0b 20 00：一条指令的字节级表示
		把一个字长的数据加到一个值上
		该值的存储地址：0x200b43加上当前程序计数器的值
		当前程序计数器的值：下一条将要执行指令的地址
	最后4个字节：43 0b 20 00
	→ 按照相反的顺序写出：00 20 0b 43
	→ 去掉开头的0：0x200b43
	书写字节序：
		最低位字节：左边
		最高位字节：右边
	通常书写数字：
		最低有效位：右边
		最高有效位：左边

编写规避正常的类型系统的程序：
	C语言：强制类型转换（cast）、联合（union） → 允许以一种数据类型引用一个对象

![](D:\Notes\CS_Books\计算机系统\深入理解计算机系统_布莱恩特等\img\图\图2-4.png)
byte_pointer：指向类型为“unsigned char”的对象的指针

![](D:\Notes\CS_Books\计算机系统\深入理解计算机系统_布莱恩特等\img\图\图2-5.png)

```c
#include <stdio.h>

typedef unsigned char* byte_pointer;

void show_bytes(byte_pointer start, size_t len) {
	size_t i;
	for (int i = 0; i < len; i++) {
		printf(" %.2x", start[i]);
	}
	printf("\n");
}

void show_int(int x) {
	show_bytes((byte_pointer)&x, sizeof(int));
}

void show_float(float x) {
	show_bytes((byte_pointer)&x, sizeof(float));
}

void show_pointer(void* x) {
	show_bytes((byte_pointer)&x, sizeof(void*));
}

void test_show_bytes(int val) {
	int ival = val;
	float fval = (float)ival;
	int* pval = &ival;
	show_int(ival);
	show_float(fval);
	show_pointer(pval);
}

int main() {
	int x = 12345;
	test_show_bytes(x);

	return 0;
}
```

运行结果：

```
 39 30 00 00
 00 e4 40 46
 14 f4 6f 9f 11 00 00 00
```

![](D:\Notes\CS_Books\计算机系统\深入理解计算机系统_布莱恩特等\img\图\图2-6.png)

|          | 操作系统 |         处理器         |
| :------: | :------: | :--------------------: |
| Linux 32 |  Linux   |       Intel IA32       |
| Windows  | Windows  |       Intel IA32       |
|   Sun    | Solaris  | Sun Microsystems SPARC |
| Linux 64 |  Linux   |      Intel x86-64      |

12345的十六进制表示：0x00003039
小端法机器：Linux 32、Windows、Linux 64
	最低有效字节值0x39：最先输出
大端法机器：Sun
	最低有效字节值0x39：最后输出

指针值：完全不同
	不同的机器/操作系统配置：使用不同的存储分配规则

4字节地址：Linux 32、Windows、Sun
8字节地址：Linux 64

对数值12345编码：
	整型：0x00003039
	浮点数：0x4640E400
	有13个相匹配的位的序列：
![](D:\Notes\CS_Books\计算机系统\深入理解计算机系统_布莱恩特等\img\文本\33-1.png)



### 2.1.4 表示字符串

C语言：
	字符串：以null（其值为0）字符结尾的字符数组
		每个字符：某个标准编码
			ASCII字符码：
				十进制数字*x*：0x3*x*
				终止字节：0x00
文本数据：比二进制数据具有更强的平台独立性

文字编码的Unicode标准：
	Unicode联合会（Unicode Consortium）
	Unicode标准（7.0版）的字库：100 000个字符
	基本编码 / Unicode 的“统一字符集”：
		表示字符：32位
		替代编码：
			常见的字符：1个或2个字节
			不太常用的字符：多一些字节数
		UTF-8：
			所有的ASCII字节序列：用ASCII码表示 = 用UTF-8表示
	Java编程语言：
		表示字符串：Unicode
	C语言：
		有支持Unicode的程序库



### 2.1.5 表示代码

![](D:\Notes\CS_Books\计算机系统\深入理解计算机系统_布莱恩特等\img\文本\35-1.png)
编译生成如下字节表示的机器代码：
![](D:\Notes\CS_Books\计算机系统\深入理解计算机系统_布莱恩特等\img\文本\35-2.png)

不同的机器类型：不同的且不兼容的指令和编码方式
不同的操作系统：不同的编码规则
→ 二进制代码：不兼容的，很少能在不同机器和操作系统组合之间移植

程序 = 字节序列（机器的角度）



### 2.1.6 布尔代数简介

二进制值：计算机编码、存储和操作信息的核心

1850年前后
乔治·布尔（George Boole，1815-1864）
布尔代数（Boolean algebra）

|   逻辑值    | 二进制值 |
| :---------: | :------: |
| TRUE（真）  |    1     |
| FALSE（假） |    0     |

![](D:\Notes\CS_Books\计算机系统\深入理解计算机系统_布莱恩特等\img\图\图2-7.png)

| 布尔运算 | 逻辑运算 | 命题逻辑 |
| :------: | :------: | :------: |
|    ~     |   NOT    |    ¬     |
|    &     |   AND    |    ∧     |
|    \|    |    OR    |    ∨     |
|    ^     |   异或   |    ⊕     |

信息论
Claude Shannon（1916-2001）：建立了布尔代数和数字逻辑之间的联系
	1937年，硕士论文：布尔代数可以用来设计和分析机电继电器网络

布尔运算 → 位向量的运算
位向量：固定长度为w、由0和1组成的串
位向量的运算：参数的每个对应元素之间的运算

![](D:\Notes\CS_Books\计算机系统\深入理解计算机系统_布莱恩特等\img\文本\36-1.png)

关于布尔代数和布尔环的更多内容：
	布尔运算：
		&对|的分配律：a&(b|c) = (a&b)|(a&c)
		|对&的分配律：a|(b&c) = (a|b)&(a|c)
	布尔环（Boolean ring）
		如：a^a = 0

位向量[a<sub>w-1</sub>, ... , a<sub>1</sub>, a<sub>0</sub>] → 编码：任何子集A⊆{0, 1, ... , w-1}，其中a<sub>i</sub>=1当且仅当i∈A
	如：
		位向量a≐[01101001] → 集合A={0, 3, 5, 6}
		位向量b≐[01010101] → 集合B={0, 2, 4, 6}
	布尔运算| → 集合的并
	布尔运算& → 集合的交
	布尔运算~ → 集合的补
		如：运算a&b=[01000001] → A∩B={0, 6}

用位向量对集合编码：
	第8章：
		信号：中断程序执行
		位向量掩码：有选择地使能/屏蔽一些信号
			1：该信号是有效的（使能）
			0：该信号是被屏蔽的
			掩码：有效信号的集合



### 2.1.7 C语言中的位级运算

|：OR（或）
&：AND（与）
~：NOT（取反）
^：EXCLUSIVE-OR（异或）
	能运用到任何“整型”的数据类型上

一些对char数据类型表达式求值的例子：
![](D:\Notes\CS_Books\计算机系统\深入理解计算机系统_布莱恩特等\img\文本\37-1.png)

位运算：
	常见用法：实现掩码运算
	掩码0xFF：一个字的低位字节
		位运算x&0xFF = 一个由x的最低有效字节组成的值
			如：x=0x89ABCDEF → x&0xFF = 0x000000EF



### 2.1.8 C语言中的逻辑运算

| C语言的逻辑运算符 | 命题逻辑中的运算 |
| :---------------: | :--------------: |
|       \|\|        |        OR        |
|        &&         |       AND        |
|         !         |       NOT        |

逻辑运算：

| 参数 | 表示  |
| :--: | :---: |
| 非零 | TRUE  |
|  0   | FALSE |

| 返回 | 表示  |
| :--: | :---: |
|  1   | TRUE  |
|  0   | FALSE |

![](D:\Notes\CS_Books\计算机系统\深入理解计算机系统_布莱恩特等\img\文本\39-1.png)

区别：
	逻辑运算：&&、||
	位级运算：&、|
	**如果对第一个参数求值就能确定表达式的结果，那么逻辑运算符就不会对第二个参数求值。**
	如：
		表达式a&&5/a → 不会造成被零除
		表达式p&&*p++ → 不会导致间接引用空指针



### 2.1.9 C语言中的移位运算

操作数x：[x<sub>w-1</sub>, x<sub>w-2</sub>, ... , x<sub>0</sub>]

左移运算：
	C表达式x<<k → [x<sub>w-k-1</sub>, x<sub>w-k-2</sub>, ... , x<sub>0</sub>, 0, ... , 0]
	x向左移动k位，丢弃最高的k位，并在右端补k个0
	位移量：0~w-1

右移运算：
	x>>k
	逻辑右移：
		在左端补k个0 → [0, ... , 0, x<sub>w-1</sub>, x<sub>w-2</sub>, ... , x<sub>k</sub>]
	算术右移：
		在左端补k个最高有效位的值 → [x<sub>w-1</sub>, ... , x<sub>w-1</sub>, x<sub>w-1</sub>, x<sub>w-2</sub>, ... , x<sub>k</sub>]

对一个8位参数x的两个不同的值做不同的移位操作得到的结果：
![](D:\Notes\CS_Books\计算机系统\深入理解计算机系统_布莱恩特等\img\文本\40-1.png)

C语言标准：没有明确定义对于有符号数应该使用哪种类型的右移
	几乎所有的编译器/机器组合都对有符号数使用算术右移
	无符号数：逻辑右移

Java：
	x>>k：算术右移
	x>>>k：逻辑右移

移动k位，这里k很大：
	数据类型：w位
	位移k≥w位
	C语言标准：规避说明
		许多机器上：只考虑位移量的低log<sub>2</sub>w位 → 实际位移量 = k mod w
![](D:\Notes\CS_Books\计算机系统\深入理解计算机系统_布莱恩特等\img\文本\41-1.png)
![](D:\Notes\CS_Books\计算机系统\深入理解计算机系统_布莱恩特等\img\文本\41-2.png)
	Java：
		位移数量的计算：求模的方法



## 2.2 整数表示

用位来编码整数的两种不同的方式：
	非负数
	负数、零、正数

数学术语：
![](D:\Notes\CS_Books\计算机系统\深入理解计算机系统_布莱恩特等\img\图\图2-8.png)



### 2.2.1 整数数据类型

C语言：
	支持：多种整型数据类型 → 表示：有限范围的整数
	关键字：char、short、int、long
	唯一一个与机器相关的取值范围：long
		大多数64位机器：8个字节
		32位机器：4个字节

![](D:\Notes\CS_Books\计算机系统\深入理解计算机系统_布莱恩特等\img\图\图2-9.png)

![](D:\Notes\CS_Books\计算机系统\深入理解计算机系统_布莱恩特等\img\图\图2-10.png)

特点：取值范围不是对称的——负数的范围比整数的范围大1

C语言标准：
	每种数据类型：必须能够表示的最小的取值范围
![](D:\Notes\CS_Books\计算机系统\深入理解计算机系统_布莱恩特等\img\图\图2-11.png)
	int：可以用2个字节的数字实现
	long：可以用4个字节的数字实现

C、C++：有符号数（默认）、无符号数
Java：有符号数



### 2.2.2 无符号数的编码